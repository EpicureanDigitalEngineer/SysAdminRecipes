{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"System Administration Recipes \u00b6 Introduction \u00b6 System Administration Recipes is a collection of recipes (HowTos, instructables, cheat sheets, etc .) for installing, maintaining and operating digital services. The recipes may prove interesting for system administrators who may in turn wish to help those recipes stay up-to-date and evolve. The first theme of the collection is FreeBSD : recipes to install, configure and maintain FreeBSD as a basis for running and providing digital services (like blogging platforms, document repositories, photo libraries, etc .). They include how to install a secure (encrypted, mirrored) FreeBSD server when you have no access to the console on boot and how to deliver services by installing and maintaining a system of Jails on your FreeBSD server . The collection includes also how to install various services on your FreeBSD server or Jail, like installing and maintaining a ghost blogging platform . Future topics may include dc-in-a-box (running a data centre on a single box using a FreeBSD hypervisor ala Proxmox); home automation with Home Assistant; digital management of photos/ebooks/documents/passwords/configurations. Points of attention \u00b6 Warning If System Administration is the noble art of making computers work, System Administrators have also the responsibility when things don't work (which may be more often than we care to admit). While the recipes have all been tested as advertised, your mileage may vary when applying them. Make sure you know what you are doing when following any recipe as executing root-level commands may lead to catastrophic failure for your systems. And feel free to propose changes that will make the recipes better. Warning Almost all recipes are based on choices the author has made based on his/her own analysis of suitability and risks involved. You should always validate if these choices match your own risk assesement and like a good chef, create the necessary variants that satisfy your risk appetite. The Epicurean Digital Engineer Licence \u00b6 Copyright (C) The Epicurean Digital Engineer These pages are licenced under a Creative Commons Attribution Non Commercial 4.0 international Licence .","title":"SysAdmin Recipes"},{"location":"#system-administration-recipes","text":"","title":"System Administration Recipes"},{"location":"#introduction","text":"System Administration Recipes is a collection of recipes (HowTos, instructables, cheat sheets, etc .) for installing, maintaining and operating digital services. The recipes may prove interesting for system administrators who may in turn wish to help those recipes stay up-to-date and evolve. The first theme of the collection is FreeBSD : recipes to install, configure and maintain FreeBSD as a basis for running and providing digital services (like blogging platforms, document repositories, photo libraries, etc .). They include how to install a secure (encrypted, mirrored) FreeBSD server when you have no access to the console on boot and how to deliver services by installing and maintaining a system of Jails on your FreeBSD server . The collection includes also how to install various services on your FreeBSD server or Jail, like installing and maintaining a ghost blogging platform . Future topics may include dc-in-a-box (running a data centre on a single box using a FreeBSD hypervisor ala Proxmox); home automation with Home Assistant; digital management of photos/ebooks/documents/passwords/configurations.","title":"Introduction"},{"location":"#points-of-attention","text":"Warning If System Administration is the noble art of making computers work, System Administrators have also the responsibility when things don't work (which may be more often than we care to admit). While the recipes have all been tested as advertised, your mileage may vary when applying them. Make sure you know what you are doing when following any recipe as executing root-level commands may lead to catastrophic failure for your systems. And feel free to propose changes that will make the recipes better. Warning Almost all recipes are based on choices the author has made based on his/her own analysis of suitability and risks involved. You should always validate if these choices match your own risk assesement and like a good chef, create the necessary variants that satisfy your risk appetite. The Epicurean Digital Engineer","title":"Points of attention"},{"location":"#licence","text":"Copyright (C) The Epicurean Digital Engineer These pages are licenced under a Creative Commons Attribution Non Commercial 4.0 international Licence .","title":"Licence"},{"location":"notyet/","text":"Placeholder for a new idea \u00b6 If you would like to see this recipe, please open an issue in GitHub.","title":"A Windows Domain Controller using SAMBA on FreeBSD"},{"location":"notyet/#placeholder-for-a-new-idea","text":"If you would like to see this recipe, please open an issue in GitHub.","title":"Placeholder for a new idea"},{"location":"freebsd/","text":"FreeBSD Recipes \u00b6 This is a collection of sysadmin recipes for FreeBSD. The include recipes to install the OS in specific circumstances or to install and run services under FreeBSD. Using FreeBSD is a question of choice. Be it its pedigree , its philosophy or its rock-solid performance, the question of choosing an operating system that matches your needs is sufficiently debated on the internet fora. The recipes provided here are for those of us that have chosen to use FreeBSD (mostly) as a server operating system. OS-level installation recipes \u00b6 Installing a secure ( encrypted , mirrored ) FreeBSD system on a dedicated server when lacking console access . Installing and maintaining FreeBSD Jails the traditional way . Service installation recipes \u00b6 Installing the ghost blogging platform under FreeBSD","title":"About FreeBSD Recipes"},{"location":"freebsd/#freebsd-recipes","text":"This is a collection of sysadmin recipes for FreeBSD. The include recipes to install the OS in specific circumstances or to install and run services under FreeBSD. Using FreeBSD is a question of choice. Be it its pedigree , its philosophy or its rock-solid performance, the question of choosing an operating system that matches your needs is sufficiently debated on the internet fora. The recipes provided here are for those of us that have chosen to use FreeBSD (mostly) as a server operating system.","title":"FreeBSD Recipes"},{"location":"freebsd/#os-level-installation-recipes","text":"Installing a secure ( encrypted , mirrored ) FreeBSD system on a dedicated server when lacking console access . Installing and maintaining FreeBSD Jails the traditional way .","title":"OS-level installation recipes"},{"location":"freebsd/#service-installation-recipes","text":"Installing the ghost blogging platform under FreeBSD","title":"Service installation recipes"},{"location":"freebsd/ghost/","text":"Installing the ghost blogging platform under FreeBSD 12.x \u00b6 Problem Statement \u00b6 This recipe provides instructions to install and maintain the ghost blogging platform under FreeBSD which is not available as a separate package. There are no detailed installation instructions on the ghost site, but the app runs well and true under FreeBSD. Concepts \u00b6 ghost runs on the following stack: NodeJS , MySQL ( NGINX | HAProxy | Apache ), mail . The required modules can be found here . This recipe should be ideally be executed in a FreeBSD jail to allow isolation of the services but may also be installed on a standard system. For this recipe we consider the current machine has the address blog.example.com and no prior installation of any of the required stack services. A mail client should be available and operating on the system (e.g. ssmtp ) to allow ghost to communicate with the outside world. We don't treat here how to expose the service to the internet securely (e.g. behind a reverse proxy like HAProxy or Nginx ). Install the required stack \u00b6 [ root@ghost / ] $ pkg install node10 npm-node10 mysql57-server Check that packages are correctly installed: [ root@ghost / ] $ node --version v10.16.3 [ root@ghost / ] $ npm --version 6 .11.3 Configure MySQL \u00b6 Prepare a secure installation of MySQL: [ root@ghost / ] $ sysrc mysql_enable = \"YES\" mysql_enable: -> YES [ root@ghost / ] $ service mysql-server start Starting mysql. [ root@ghost / ] $ mysql_secure_installation ... [ root@ghost / ] $ mysql -u root -p root@localhost [( none )] > ALTER USER 'root' @ 'localhost' IDENTIFIED WITH mysql_native_password BY 'ENTERNEWPASSHERE' ; root@localhost [( none )] > exit ; Install ghost \u00b6 Create a system user for ghost \u00b6 [ root@ghost / ] $ adduser ghost Username: ghost Full name: Ghost User Uid ( Leave empty for default ) : Login group [ ghost ] : Login group is ghost. Invite ghost into other groups? [] : www Login class [ default ] : Shell ( sh csh tcsh bash rbash nologin ) [ sh ] : Home directory [ /home/ghost ] : Home directory permissions ( Leave empty for default ) : Use password-based authentication? [ yes ] : Use an empty password? ( yes/no ) [ no ] : Use a random password? ( yes/no ) [ no ] : yes Lock out the account after creation? [ no ] : Username : ghost Password : <random> Full Name : Ghost User Uid : 1001 Class : Groups : ghost www Home : /home/ghost Home Mode : Shell : /bin/sh Locked : no OK? ( yes/no ) : yes adduser: INFO: Successfully added ( ghost ) to the user database. adduser: INFO: Password for ( ghost ) is: xyz Install ghost-cli \u00b6 [ root@ghost / ] $ npm i -g ghost-cli ... [ root@ghost / ] $ mkdir -p /usr/local/www/ghost [ root@ghost / ] $ chown ghost:ghost /usr/local/www/ghost [ root@ghost / ] $ chmod 775 /usr/local/www/ghost [ root@ghost / ] $ cd /usr/local/www/ghost [ root@ghost /usr/local/www/ghost ] $ su ghost -c bash [ ghost@ghost /usr/local/www/ghost ] $ ghost install \u2714 Checking system Node.js version \u2714 Checking current folder permissions System checks failed with message: 'Operating system is not Linux' Some features of Ghost-CLI may not work without additional configuration. For local installs we recommend using ` ghost install local ` instead. ? Continue anyway? Yes System stack check skipped \u2139 Checking operating system compatibility [ skipped ] Local MySQL install not found. You can ignore this if you are using a remote MySQL host. Alternatively you could: a ) install MySQL locally b ) run ` ghost install --db = sqlite3 ` to use sqlite c ) run ` ghost install local ` to get a development install using sqlite3. ? Continue anyway? Yes MySQL check skipped \u2139 Checking for a MySQL installation [ skipped ] \u2714 Checking memory availability \u2714 Checking for latest Ghost version \u2714 Setting up install directory \u2714 Downloading and installing Ghost v3.2.0 \u2714 Finishing install process ? Enter your blog URL: https://kd.blogs.dryllerakis.eu/ ? Enter your MySQL hostname: localhost ? Enter your MySQL username: root ? Enter your MySQL password: [ hidden ] ? Enter your Ghost database name: ghost_prod \u2714 Configuring Ghost \u2714 Setting up instance ? Do you wish to set up \"ghost\" mysql user? Yes \u2716 Setting up \"ghost\" mysql user Nginx is not installed. Skipping Nginx setup. \u2139 Setting up Nginx [ skipped ] Nginx setup task was skipped, skipping SSL setup \u2139 Setting up SSL [ skipped ] ? Do you wish to set up Systemd? No \u2139 Setting up Systemd [ skipped ] Process manager 'systemd' will not run on this system, defaulting to 'local' ? Do you want to start Ghost? Yes \u2714 Starting Ghost Ghost uses direct mail by default. To set up an alternative email method read our docs at https://ghost.org/docs/concepts/config/#mail ------------------------------------------------------------------------------ Ghost was installed successfully! To complete setup of your publication, visit: https://blog.example.com/ghost/ Create a start-up script for FreeBSD \u00b6 Script: /usr/local/etc/rc.d/ghost #!/bin/sh # PROVIDE: ghost # REQUIRE: mysql-server # KEYWORD: shutdown PATH = \"/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin\" . /etc/rc.subr name = \"ghost\" rcvar = \"ghost_enable\" load_rc_config ghost : ${ ghost_enable := \"NO\" } : ${ ghost_msg = \"Ghost did not start\" } start_cmd = \" ${ name } _start\" stop_cmd = \" ${ name } _stop\" stop_postcmd = \"echo Ghost stopped\" restart_cmd = \" ${ name } _restart\" required_dirs = \" $ghost_path \" ghost_start () { su -m ghost -c \"cd $ghost_path && ghost start\" } ghost_stop () { su -m ghost -c \"cd $ghost_path && ghost stop\" } ghost_restart () { su -m ghost -c \"cd $ghost_path && ghost restart\" } run_rc_command \" $1 \" \u200b ``` bash and add it to the ` rc.conf ` : \u200b ``` bash [ root@ghost / ] $ sysrc ghost_enable = \"YES\" [ root@ghost / ] $ sysrc ghost_path = \"/usr/local/www/ghost\" Finally, update the config file to use ssmtp or sendmail for mailing: $ sed -ie 's/Direct/sendmail/g' config.production.json Configure ghost \u00b6 Update configuration to use sendmail ( ssmtp ) configure reverse proxy ( HAProxy ) to expose blog to the internet Updating ghost \u00b6 ssh to the jail or OS navigate to /usr/local/www/ghost run su ghost run ghost update voil\u00e0 see here for more info References \u00b6 [[https://idontwatch.tv/installing-ghost-on-freebsd-11-1/]] [[https://linoxide.com/linux-how-to/install-ghost-nginx-freebsd-10-2/]]","title":"Installing the ghost blogging platform in FreeBSD"},{"location":"freebsd/ghost/#installing-the-ghost-blogging-platform-under-freebsd-12x","text":"","title":"Installing the ghost blogging platform under FreeBSD 12.x"},{"location":"freebsd/ghost/#problem-statement","text":"This recipe provides instructions to install and maintain the ghost blogging platform under FreeBSD which is not available as a separate package. There are no detailed installation instructions on the ghost site, but the app runs well and true under FreeBSD.","title":"Problem Statement"},{"location":"freebsd/ghost/#concepts","text":"ghost runs on the following stack: NodeJS , MySQL ( NGINX | HAProxy | Apache ), mail . The required modules can be found here . This recipe should be ideally be executed in a FreeBSD jail to allow isolation of the services but may also be installed on a standard system. For this recipe we consider the current machine has the address blog.example.com and no prior installation of any of the required stack services. A mail client should be available and operating on the system (e.g. ssmtp ) to allow ghost to communicate with the outside world. We don't treat here how to expose the service to the internet securely (e.g. behind a reverse proxy like HAProxy or Nginx ).","title":"Concepts"},{"location":"freebsd/ghost/#install-the-required-stack","text":"[ root@ghost / ] $ pkg install node10 npm-node10 mysql57-server Check that packages are correctly installed: [ root@ghost / ] $ node --version v10.16.3 [ root@ghost / ] $ npm --version 6 .11.3","title":"Install the required stack"},{"location":"freebsd/ghost/#configure-mysql","text":"Prepare a secure installation of MySQL: [ root@ghost / ] $ sysrc mysql_enable = \"YES\" mysql_enable: -> YES [ root@ghost / ] $ service mysql-server start Starting mysql. [ root@ghost / ] $ mysql_secure_installation ... [ root@ghost / ] $ mysql -u root -p root@localhost [( none )] > ALTER USER 'root' @ 'localhost' IDENTIFIED WITH mysql_native_password BY 'ENTERNEWPASSHERE' ; root@localhost [( none )] > exit ;","title":"Configure MySQL"},{"location":"freebsd/ghost/#install-ghost","text":"","title":"Install ghost"},{"location":"freebsd/ghost/#create-a-system-user-for-ghost","text":"[ root@ghost / ] $ adduser ghost Username: ghost Full name: Ghost User Uid ( Leave empty for default ) : Login group [ ghost ] : Login group is ghost. Invite ghost into other groups? [] : www Login class [ default ] : Shell ( sh csh tcsh bash rbash nologin ) [ sh ] : Home directory [ /home/ghost ] : Home directory permissions ( Leave empty for default ) : Use password-based authentication? [ yes ] : Use an empty password? ( yes/no ) [ no ] : Use a random password? ( yes/no ) [ no ] : yes Lock out the account after creation? [ no ] : Username : ghost Password : <random> Full Name : Ghost User Uid : 1001 Class : Groups : ghost www Home : /home/ghost Home Mode : Shell : /bin/sh Locked : no OK? ( yes/no ) : yes adduser: INFO: Successfully added ( ghost ) to the user database. adduser: INFO: Password for ( ghost ) is: xyz","title":"Create a system user for ghost"},{"location":"freebsd/ghost/#install-ghost-cli","text":"[ root@ghost / ] $ npm i -g ghost-cli ... [ root@ghost / ] $ mkdir -p /usr/local/www/ghost [ root@ghost / ] $ chown ghost:ghost /usr/local/www/ghost [ root@ghost / ] $ chmod 775 /usr/local/www/ghost [ root@ghost / ] $ cd /usr/local/www/ghost [ root@ghost /usr/local/www/ghost ] $ su ghost -c bash [ ghost@ghost /usr/local/www/ghost ] $ ghost install \u2714 Checking system Node.js version \u2714 Checking current folder permissions System checks failed with message: 'Operating system is not Linux' Some features of Ghost-CLI may not work without additional configuration. For local installs we recommend using ` ghost install local ` instead. ? Continue anyway? Yes System stack check skipped \u2139 Checking operating system compatibility [ skipped ] Local MySQL install not found. You can ignore this if you are using a remote MySQL host. Alternatively you could: a ) install MySQL locally b ) run ` ghost install --db = sqlite3 ` to use sqlite c ) run ` ghost install local ` to get a development install using sqlite3. ? Continue anyway? Yes MySQL check skipped \u2139 Checking for a MySQL installation [ skipped ] \u2714 Checking memory availability \u2714 Checking for latest Ghost version \u2714 Setting up install directory \u2714 Downloading and installing Ghost v3.2.0 \u2714 Finishing install process ? Enter your blog URL: https://kd.blogs.dryllerakis.eu/ ? Enter your MySQL hostname: localhost ? Enter your MySQL username: root ? Enter your MySQL password: [ hidden ] ? Enter your Ghost database name: ghost_prod \u2714 Configuring Ghost \u2714 Setting up instance ? Do you wish to set up \"ghost\" mysql user? Yes \u2716 Setting up \"ghost\" mysql user Nginx is not installed. Skipping Nginx setup. \u2139 Setting up Nginx [ skipped ] Nginx setup task was skipped, skipping SSL setup \u2139 Setting up SSL [ skipped ] ? Do you wish to set up Systemd? No \u2139 Setting up Systemd [ skipped ] Process manager 'systemd' will not run on this system, defaulting to 'local' ? Do you want to start Ghost? Yes \u2714 Starting Ghost Ghost uses direct mail by default. To set up an alternative email method read our docs at https://ghost.org/docs/concepts/config/#mail ------------------------------------------------------------------------------ Ghost was installed successfully! To complete setup of your publication, visit: https://blog.example.com/ghost/","title":"Install ghost-cli"},{"location":"freebsd/ghost/#create-a-start-up-script-for-freebsd","text":"Script: /usr/local/etc/rc.d/ghost #!/bin/sh # PROVIDE: ghost # REQUIRE: mysql-server # KEYWORD: shutdown PATH = \"/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin\" . /etc/rc.subr name = \"ghost\" rcvar = \"ghost_enable\" load_rc_config ghost : ${ ghost_enable := \"NO\" } : ${ ghost_msg = \"Ghost did not start\" } start_cmd = \" ${ name } _start\" stop_cmd = \" ${ name } _stop\" stop_postcmd = \"echo Ghost stopped\" restart_cmd = \" ${ name } _restart\" required_dirs = \" $ghost_path \" ghost_start () { su -m ghost -c \"cd $ghost_path && ghost start\" } ghost_stop () { su -m ghost -c \"cd $ghost_path && ghost stop\" } ghost_restart () { su -m ghost -c \"cd $ghost_path && ghost restart\" } run_rc_command \" $1 \" \u200b ``` bash and add it to the ` rc.conf ` : \u200b ``` bash [ root@ghost / ] $ sysrc ghost_enable = \"YES\" [ root@ghost / ] $ sysrc ghost_path = \"/usr/local/www/ghost\" Finally, update the config file to use ssmtp or sendmail for mailing: $ sed -ie 's/Direct/sendmail/g' config.production.json","title":"Create a start-up script for FreeBSD"},{"location":"freebsd/ghost/#configure-ghost","text":"Update configuration to use sendmail ( ssmtp ) configure reverse proxy ( HAProxy ) to expose blog to the internet","title":"Configure ghost"},{"location":"freebsd/ghost/#updating-ghost","text":"ssh to the jail or OS navigate to /usr/local/www/ghost run su ghost run ghost update voil\u00e0 see here for more info","title":"Updating ghost"},{"location":"freebsd/ghost/#references","text":"[[https://idontwatch.tv/installing-ghost-on-freebsd-11-1/]] [[https://linoxide.com/linux-how-to/install-ghost-nginx-freebsd-10-2/]]","title":"References"},{"location":"freebsd/jails/","text":"How to install (a set of) FreeBSD Jails (on 12.x) \u00b6 Problem Statement \u00b6 Having installed a FreeBSD server, you now want to run multiple services (e.g. a blogging platform , a NextCloud instance, ...) in a controlled and secure manner. Under Linux, you would have used containers . Under FreeBSD, you use jails . Jails appeared much earlier than containers and they addressed specifically the issue of isolating a set of processes from each other to obtain multi-tenancy of services in a more controllable and secure way. Various meta-systems exist to manage jails, ezjail among them. This recipe explains how to create a set of jails in an already existing and configured FreeBSD 12.x server (see for example here how to install a FreeBSD secure server in the cloud). It does not use any meta-tools like ezjail but proposes a set of conventions and concepts that facilitate the management of jails the low-level way. Therefore, it is addressed to those want to have a good understanding and control of what is happening under the hood. Concepts \u00b6 Running services in jails in FreeBSD is the \"equivalent\" to running services in containers in Linux (without the automation!). Jails can be configured in different ways to serve different purposes. Here, we consider that a jail is a miniature FreeBSD machine which is created to run specific services in a walled environment and which has its own network stack bridging the jail interfaces with the physical, uplink interface. We expected that the host FreeBSD server will eventually have multiple jails. The configuration of the jail system resides in /etc/jails . It is in this file that we will be establishing a set of conventions that should make the management of the collection of jails (and the creation of new us) considerably more manageable. The file allows some parametrisation as well as the execution of scripts that automate a number of tasks like networking. Conventions/patterns used include the following: Jail Location : Jails are installed under under /jail/<jail name> . In case you are using zfs you should be creating a new dataset accordingly and take advantage of the zfs functionality to arrange for snapshots, backups or migrations/cloning. Jail privileges : Jails are run as root - take good care to ensure the level of security you want to obtain from the system. Jail networking : a bridge0 is created (if not existing) upon start of the first jail . Each jail is assigned an epair interface named jail0 inside the jail. The outside part of the pair is added to the bridge. The uplink interface is also added to the bridge, effectively allowing jails to have a full networking stack (including loopback). When a jail is stopped, the corresponding epair interface is removed from the bridge and destroyed. Based on these conventions once your /etc/jails template has been prepared, adding a jail to the host system requires just two steps: create a directory (or zfs dataset ) and install the required jail files; perform initial basic configuration append information about your jail to the /etc/jails.conf file and start the jail The size of FreeBSD allows the jails to be relatively compact: 587MB for the base install or 1.6GB with the ports tree and current portsnap(8) information. As the jail is seen as an independent system, it will need to be maintained as a separate system (i.e. through freebsd-update and pkg upgrade ). For the sake of example, the name of the host will be host while the the name of the jail to be created would be myjail1 . Installation process for a new jail \u00b6 Configure and start the jail service with the conventions decided (if not done) Create a space for your new jail and perform the basic installation/configuration Update the /etc/jails.conf file to make your jail known Start the jail and finalise the configuration Configure the Jail subsystem on the host \u00b6 /etc/rc.conf and /etc/jail.conf Add an entry for myjail on /etc/hosts (\\'\\'10.166.167.20 dc03\\'\\') of the host machine. If not already done, add jail_enable=\"YES\" to /etc/rc.conf ################################################################ ## /etc/jail.conf # ## Basic Jail configuration for multiple Jails # ## The Epicurean Digital Engineer - 2020 # ################################################################ ## Global section exec.system_user = \"root\" ; exec.jail_user = \"root\" ; mount.devfs ; allow.raw_sockets ; allow.sysvipc ; devfs_ruleset = \"5\" ; ## Networking $uplinkdev = \"re0\" ; vnet ; vnet.interface = \"jail0\" ; # default vnet interface exec.prestart = \"ifconfig bridge0 > /dev/null 2> /dev/null || ( ifconfig bridge0 create up && ifconfig bridge0 addm $uplinkdev )\" ; exec.prestart + = \"ifconfig $epair create up || echo 'Skipped creating epair(exists?)'\" ; exec.prestart + = \"ifconfig bridge0 addm ${ epair } a || echo 'Skipped adding bridge member (already member?)'\" ; exec.created = \"ifconfig ${ epair } b name jail0 || echo 'Skipped renaming ifdev to jail0 (looks bad...)'\" ; exec.clean ; exec.start = \"/bin/sh /etc/rc\" ; exec.stop = \"/bin/sh /etc/rc.shutdown\" ; exec.poststop = \"ifconfig bridge0 deletem ${ epair } a\" ; exec.poststop + = \"ifconfig ${ epair } a destroy\" ; # # Information about individual jails # provided here for reference # to be added only when a jail is added! # myjail1 { host.hostname = myjail1.example.com ; path = /jail/myjail1 ; $epair = \"epair0\" ; # must be unique in every jail } myjail2 { host.hostname = myjail2.example.com ; path = /jail/myjail2 ; $epair = \"epair1\" ; # must be unique in every jail } myjail3 { host.hostname = myjail2.example.com ; path = /jail/myjail3 ; $epair = \"epair2\" ; # must be unique in every jail } Create the jail \u00b6 The complete Jail after finished installation takes less size then 587 MB. With complete FreeBSD Ports tree and current portsnap(8) information it takes about 1.6 GB of space. $ mkdir -p /jail/myjail # for a ufs installation $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/base.txz | tar --unlink -xpJf - -C /jail/myjail Configure the host \u00b6 Configure the jail \u00b6 ################################################################ # /etc/rc.conf for myjail - a jailed service # ################################################################ # # # Network Configuration # hostname = \"myjail.example.com\" defaultrouter = \"10.6.6.1\" ifconfig_jail0 = \"inet 10.6.6.2 netmask 255.255.255.0\" # DAEMONS | yes syslogd_flags = \"-s -s\" # DAEMONS | no sshd_enable = NO sendmail_enable = NONE sendmail_submit_enable = NO sendmail_outbound_enable = NO sendmail_msp_queue_enable = NO # OTHER clear_tmp_enable = YES clear_tmp_X = YES dumpdev = NO update_motd = NO keyrate = fast domain example.com search example.com nameserver 8.8.8.8 nameserver 1.1.1.1 [ root@host /jail ] $ chroot /jail/myjail tzsetup [ root@host /jail ] $ chroot /jail/myjail newaliases -v Start the jail \u00b6 Now that the jail has been created, you may start it and check everything works. [ root@host /jail ] $ service jail start myjail1 Starting jails: myjail1. [ root@host /jail ] $ jexec myjail1 csh Upgrade jail to the latest patch level \u00b6 To upgrade your new jail to the latest patch level use freebsd-update -b as follows: [ root@host /jail ] $ freebsd-update -v /jail/myjail1 fetch [ root@host /jail ] $ freebsd-update -v /jail/myjail1 install Note This presupposes that you are already on the latest patch level for your host system. If not, perform the freebsd-update on the host first to ensure that your kernel and userland versions will match (use uname -UK to verify if in doubt). Install the pkg system (latest version) \u00b6 To allow to receive quicker updates, we switch to the \\\"latest version\\\" pkg repository. root@myjail1:/ $ sed -i '' s/quarterly/latest/g /etc/pkg/FreeBSD.conf root@myjail1:/ $ pkg update The package management tool is not yet installed on your system. Do you want to fetch and install it now? [y/N]: y Bootstrapping pkg from pkg+http://pkg.FreeBSD.org/FreeBSD:12:amd64/latest, please wait... Verifying signature with trusted certificate pkg.freebsd.org.2013102301... done [myjail1.example.com] Installing pkg-1.12.0... [myjail1.example.com] Extracting pkg-1.12.0: 100% Updating FreeBSD repository catalogue... [myjail1.example.com] Fetching meta.txz: 100% 944 B 0.9kB/s 00:01 [myjail1.example.com] Fetching packagesite.txz: 100% 6 MiB 1.6MB/s 00:04 Processing entries: 100% FreeBSD repository update completed. 31945 packages processed. All repositories are up to date. root@dc03:/ $ pkg install -y bash Install packages you need \u00b6 Now, install any packages you may need. I tend to install my favourite shell bash","title":"A Jail-based FreeBSD Application Server"},{"location":"freebsd/jails/#how-to-install-a-set-of-freebsd-jails-on-12x","text":"","title":"How to install (a set of) FreeBSD Jails (on 12.x)"},{"location":"freebsd/jails/#problem-statement","text":"Having installed a FreeBSD server, you now want to run multiple services (e.g. a blogging platform , a NextCloud instance, ...) in a controlled and secure manner. Under Linux, you would have used containers . Under FreeBSD, you use jails . Jails appeared much earlier than containers and they addressed specifically the issue of isolating a set of processes from each other to obtain multi-tenancy of services in a more controllable and secure way. Various meta-systems exist to manage jails, ezjail among them. This recipe explains how to create a set of jails in an already existing and configured FreeBSD 12.x server (see for example here how to install a FreeBSD secure server in the cloud). It does not use any meta-tools like ezjail but proposes a set of conventions and concepts that facilitate the management of jails the low-level way. Therefore, it is addressed to those want to have a good understanding and control of what is happening under the hood.","title":"Problem Statement"},{"location":"freebsd/jails/#concepts","text":"Running services in jails in FreeBSD is the \"equivalent\" to running services in containers in Linux (without the automation!). Jails can be configured in different ways to serve different purposes. Here, we consider that a jail is a miniature FreeBSD machine which is created to run specific services in a walled environment and which has its own network stack bridging the jail interfaces with the physical, uplink interface. We expected that the host FreeBSD server will eventually have multiple jails. The configuration of the jail system resides in /etc/jails . It is in this file that we will be establishing a set of conventions that should make the management of the collection of jails (and the creation of new us) considerably more manageable. The file allows some parametrisation as well as the execution of scripts that automate a number of tasks like networking. Conventions/patterns used include the following: Jail Location : Jails are installed under under /jail/<jail name> . In case you are using zfs you should be creating a new dataset accordingly and take advantage of the zfs functionality to arrange for snapshots, backups or migrations/cloning. Jail privileges : Jails are run as root - take good care to ensure the level of security you want to obtain from the system. Jail networking : a bridge0 is created (if not existing) upon start of the first jail . Each jail is assigned an epair interface named jail0 inside the jail. The outside part of the pair is added to the bridge. The uplink interface is also added to the bridge, effectively allowing jails to have a full networking stack (including loopback). When a jail is stopped, the corresponding epair interface is removed from the bridge and destroyed. Based on these conventions once your /etc/jails template has been prepared, adding a jail to the host system requires just two steps: create a directory (or zfs dataset ) and install the required jail files; perform initial basic configuration append information about your jail to the /etc/jails.conf file and start the jail The size of FreeBSD allows the jails to be relatively compact: 587MB for the base install or 1.6GB with the ports tree and current portsnap(8) information. As the jail is seen as an independent system, it will need to be maintained as a separate system (i.e. through freebsd-update and pkg upgrade ). For the sake of example, the name of the host will be host while the the name of the jail to be created would be myjail1 .","title":"Concepts"},{"location":"freebsd/jails/#installation-process-for-a-new-jail","text":"Configure and start the jail service with the conventions decided (if not done) Create a space for your new jail and perform the basic installation/configuration Update the /etc/jails.conf file to make your jail known Start the jail and finalise the configuration","title":"Installation process for a new jail"},{"location":"freebsd/jails/#configure-the-jail-subsystem-on-the-host","text":"/etc/rc.conf and /etc/jail.conf Add an entry for myjail on /etc/hosts (\\'\\'10.166.167.20 dc03\\'\\') of the host machine. If not already done, add jail_enable=\"YES\" to /etc/rc.conf ################################################################ ## /etc/jail.conf # ## Basic Jail configuration for multiple Jails # ## The Epicurean Digital Engineer - 2020 # ################################################################ ## Global section exec.system_user = \"root\" ; exec.jail_user = \"root\" ; mount.devfs ; allow.raw_sockets ; allow.sysvipc ; devfs_ruleset = \"5\" ; ## Networking $uplinkdev = \"re0\" ; vnet ; vnet.interface = \"jail0\" ; # default vnet interface exec.prestart = \"ifconfig bridge0 > /dev/null 2> /dev/null || ( ifconfig bridge0 create up && ifconfig bridge0 addm $uplinkdev )\" ; exec.prestart + = \"ifconfig $epair create up || echo 'Skipped creating epair(exists?)'\" ; exec.prestart + = \"ifconfig bridge0 addm ${ epair } a || echo 'Skipped adding bridge member (already member?)'\" ; exec.created = \"ifconfig ${ epair } b name jail0 || echo 'Skipped renaming ifdev to jail0 (looks bad...)'\" ; exec.clean ; exec.start = \"/bin/sh /etc/rc\" ; exec.stop = \"/bin/sh /etc/rc.shutdown\" ; exec.poststop = \"ifconfig bridge0 deletem ${ epair } a\" ; exec.poststop + = \"ifconfig ${ epair } a destroy\" ; # # Information about individual jails # provided here for reference # to be added only when a jail is added! # myjail1 { host.hostname = myjail1.example.com ; path = /jail/myjail1 ; $epair = \"epair0\" ; # must be unique in every jail } myjail2 { host.hostname = myjail2.example.com ; path = /jail/myjail2 ; $epair = \"epair1\" ; # must be unique in every jail } myjail3 { host.hostname = myjail2.example.com ; path = /jail/myjail3 ; $epair = \"epair2\" ; # must be unique in every jail }","title":"Configure the Jail subsystem on the host"},{"location":"freebsd/jails/#create-the-jail","text":"The complete Jail after finished installation takes less size then 587 MB. With complete FreeBSD Ports tree and current portsnap(8) information it takes about 1.6 GB of space. $ mkdir -p /jail/myjail # for a ufs installation $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/base.txz | tar --unlink -xpJf - -C /jail/myjail","title":"Create the jail"},{"location":"freebsd/jails/#configure-the-host","text":"","title":"Configure the host"},{"location":"freebsd/jails/#configure-the-jail","text":"################################################################ # /etc/rc.conf for myjail - a jailed service # ################################################################ # # # Network Configuration # hostname = \"myjail.example.com\" defaultrouter = \"10.6.6.1\" ifconfig_jail0 = \"inet 10.6.6.2 netmask 255.255.255.0\" # DAEMONS | yes syslogd_flags = \"-s -s\" # DAEMONS | no sshd_enable = NO sendmail_enable = NONE sendmail_submit_enable = NO sendmail_outbound_enable = NO sendmail_msp_queue_enable = NO # OTHER clear_tmp_enable = YES clear_tmp_X = YES dumpdev = NO update_motd = NO keyrate = fast domain example.com search example.com nameserver 8.8.8.8 nameserver 1.1.1.1 [ root@host /jail ] $ chroot /jail/myjail tzsetup [ root@host /jail ] $ chroot /jail/myjail newaliases -v","title":"Configure the jail"},{"location":"freebsd/jails/#start-the-jail","text":"Now that the jail has been created, you may start it and check everything works. [ root@host /jail ] $ service jail start myjail1 Starting jails: myjail1. [ root@host /jail ] $ jexec myjail1 csh","title":"Start the jail"},{"location":"freebsd/jails/#upgrade-jail-to-the-latest-patch-level","text":"To upgrade your new jail to the latest patch level use freebsd-update -b as follows: [ root@host /jail ] $ freebsd-update -v /jail/myjail1 fetch [ root@host /jail ] $ freebsd-update -v /jail/myjail1 install Note This presupposes that you are already on the latest patch level for your host system. If not, perform the freebsd-update on the host first to ensure that your kernel and userland versions will match (use uname -UK to verify if in doubt).","title":"Upgrade jail to the latest patch level"},{"location":"freebsd/jails/#install-the-pkg-system-latest-version","text":"To allow to receive quicker updates, we switch to the \\\"latest version\\\" pkg repository. root@myjail1:/ $ sed -i '' s/quarterly/latest/g /etc/pkg/FreeBSD.conf root@myjail1:/ $ pkg update The package management tool is not yet installed on your system. Do you want to fetch and install it now? [y/N]: y Bootstrapping pkg from pkg+http://pkg.FreeBSD.org/FreeBSD:12:amd64/latest, please wait... Verifying signature with trusted certificate pkg.freebsd.org.2013102301... done [myjail1.example.com] Installing pkg-1.12.0... [myjail1.example.com] Extracting pkg-1.12.0: 100% Updating FreeBSD repository catalogue... [myjail1.example.com] Fetching meta.txz: 100% 944 B 0.9kB/s 00:01 [myjail1.example.com] Fetching packagesite.txz: 100% 6 MiB 1.6MB/s 00:04 Processing entries: 100% FreeBSD repository update completed. 31945 packages processed. All repositories are up to date. root@dc03:/ $ pkg install -y bash","title":"Install the pkg system (latest version)"},{"location":"freebsd/jails/#install-packages-you-need","text":"Now, install any packages you may need. I tend to install my favourite shell bash","title":"Install packages you need"},{"location":"freebsd/secure-server/","text":"Installing a secure FreeBSD 12 server on a dedicated cloud machine \u00b6 Problem Statement \u00b6 This recipe describes how to install a secure FreeBSD Server on a bare-metal server to which you have but network access (no access to the console during installation and/or during boot). It is further assumed that the physical security of the machine cannot be fully guaranteed, hence encryption methods should be used to protect the server's data. While the FreeBSD installer offers the possibility to automagically install an encrypted system, it is based on the assumption that you will have console access during boot to introduce the passkey - something not always possible. The proposed setup ensures a kernel-level software RAID-1 configuration (for data integrity/availability), operating on an encrypted filesystem using ZFS (for data confidentiality) and with an encrypted swap partition. Concepts \u00b6 The solution proposed by this recipe is based on the pattern of a two-stage booting process : a first boot in a basic ( ufs ) unencrypted partition which allows network ssh access (via key), followed by attaching the geli -encrypted filesystem (by introducing a password at command line) and the re-rooting of the running kernel to the encrypted filesystem, effectively re-booting the kernel from the new filesystem which is at this stage available un-encrypted to the kernel. Tip Re-rooting refers to the use of the reboot -r command (see man page ): After changing vfs.root.mountfrom with kenv(1) , reboot -r can be used to change the root filesystem while preserving kernel state . The pattern can be further enhanced by hardening the first boot stage to only execute the mount sequence through ssh . Such hardening will increase security but will make rescue operations (that may have to be operated under stage 1 boot) harder. It is therefore not considered in this document. Ingredients \u00b6 To be able to execute this recipe, you will need a dedicated machine to which you have network access. The machine should have two equal-sized disks and enough memory to serve the corresponding disk capacity under zfs . The installation can be done either remotely (if the machine can network-boot on a FreeBSD copy) or through the console (if you have access to the console). How to boot to FreeBSD from the console is not covered in this document. Note The recipe has been tested on a dedicated server provided by https://www.hetzner.com/ as well on VirtualBox . The machine enjoyed 2X2TB hard disks, 32GB of ECC memory and an Intel Xeon processor. Hetzner offers a \"rescue\" system, network-booting to FreeBSD and assigning a temporary password. The recipe therefore starts from a booted version of FreeBSD on your server that can be accessed from your network. Warning This installation guide is not for the faint hearted (but you already knew that if you are here). You need to really understand what you are doing to avoid catastrophic failure. You should be comfortable with FreeBSD sysadmin tasks and a patient and zen attitude. Expect the unexpected when installing an OS in a new environment (e.g. if you do install in Hetzner pay specific attention to configuring the network which requires a point-to-point configuration). Inspect your System \u00b6 Log-in to your network-booted FreeBSD image as root. Obtain initial information about your server's hardware . Processor : [ root@rescue ~ ] $ sysctl -a hw.model hw.model: Intel ( R ) Xeon ( R ) CPU E3-1246 v3 @ 3 .50GHz Memory : [ root@rescue ~ ] $ sysctl -a | grep hw.*mem hw.physmem: 33950691328 hw.usermem: 33666101248 hw.realmem: 34359738368 hw.pci.host_mem_start: 2147483648 hw.cbb.start_memory: 2281701376 Network : [ root@rescue ~ ] $ ifconfig -a re0: flags = 8843 <UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500 options = 8209b<RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,WOL_MAGIC,LINKSTATE> ether 44 :44:44:44:44:44 inet 9 .9.9.9 netmask 0xffffffc0 broadcast 9 .9.9.127 media: Ethernet autoselect ( 1000baseT <full-duplex,master> ) status: active nd6 options = 29 <PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL> Disks [ root@rescue ~ ] $ sysctl kern.disks kern.disks: ada1 ada0 [ root@rescue ~ ] $ camcontrol devlist <WDC WD2000FYYZ-01UL1B2 01 .01K03> at scbus0 target 0 lun 0 ( pass0,ada0 ) <WDC WD2000FYYZ-01UL1B2 01 .01K03> at scbus1 target 0 lun 0 ( pass1,ada1 ) <AHCI SGPIO Enclosure 1 .00 0001 > at scbus2 target 0 lun 0 ( ses0,pass2 ) [ root@rescue ~ ] $ diskinfo -v ada0 | head -n3 ada0 512 # sectorsize 2000398934016 # mediasize in bytes (1.8T) [ root@rescue ~ ] $ camcontrol identify ada0 | grep sector sectors/track 63 sector size logical 512 , physical 512 , offset 0 LBA supported 268435455 sectors LBA48 supported 3907029168 sectors Physical sector sizes Take note of your physical sector size: It is important to take note of the size of your physical sector (here 512 bytes) to ensure correct alignment when creating the ZFS partitions. Example of 4K physical disk sectors: [ root@rescue ~ ] $ camcontrol identify ada0 | grep sector sectors/track 63 sector size logical 512 , physical 4096 , offset 0 LBA supported 268435455 sectors LBA48 supported 7814037168 sectors Steps \u00b6 Partition the disks \u00b6 Following inspection of our system, we have recorded that the two disks are ada0 and ada1 with 512byte physical sectors. We partition each disks in 4 partitions each, using GPT: a (very small) boot partition (for the ufs-bootcode) a 2GB ufs FreeBSD-root partition to be mirrored (for the pre-boot FreeBSD version) an 8GB swap partition (to be encrypted and mirrored) what remains goes in a FreeBSD-zfs partition (to be encrypted using geli and gmirror or zfs mirror ) for n in 0 1 ; do \\ align = 512 # change to 4k if necessary gpart destroy -F ada ${ n } ; \\ gpart create -s gpt ada ${ n } ; \\ gpart add -b 64 -s 64k -t freebsd-boot ada ${ n } ; \\ gpart add -l boot ${ n } -s 2G -t freebsd-ufs -a ${ align } ada ${ n } ; \\ gpart add -l swap ${ n } -s 8G -t freebsd-swap -a ${ align } ada ${ n } ; \\ gpart add -l zroot ${ n } -t freebsd-zfs -a ${ align } ada ${ n } ; \\ gpart bootcode -b /boot/pmbr -p /boot/gptboot -i 1 ada ${ n } ; \\ done [ root@rescue ~ ] $ for n in 0 1 ; do \\ > align = 512 # change to 4k if necessary > gpart destroy -F ada ${ n } ; \\ > gpart create -s gpt ada ${ n } ; \\ > gpart add -b 64 -s 64k -t freebsd-boot ada ${ n } ; \\ > gpart add -l boot ${ n } -s 2G -t freebsd-ufs -a ${ align } ada ${ n } ; \\ > gpart add -l swap ${ n } -s 8G -t freebsd-swap -a ${ align } ada ${ n } ; \\ > gpart add -l zroot ${ n } -t freebsd-zfs -a ${ align } ada ${ n } ; \\ > gpart bootcode -b /boot/pmbr -p /boot/gptboot -i 1 ada ${ n } ; \\ > done gpart: arg0 'ada0' : Invalid argument ada0 created ada0p1 added ada0p2 added ada0p3 added ada0p4 added partcode written to ada0p1 bootcode written to ada0 gpart: arg0 'ada1' : Invalid argument ada1 created ada1p1 added ada1p2 added ada1p3 added ada1p4 added partcode written to ada1p1 bootcode written to ada1 Note that the errors noticed above can be safely ignored. They simply indicate that no partition table existed before to be deleted. Prepare the mirrors for swap and boot \u00b6 Mirroring for the ufs and swap partitions will happen using the geom_mirror kernel module. Encryption will be done using the geli system. We encrypt the swap partition dynamically while we encrypt the zfs partition with a strong password. The ZFS filesystem will perform its own mirroring. Do not forget to adapt the sector size for geli if necessary (e.g. 4096 instead of 512)! [ root@rescue / ] $ kldload geom_mirror [ root@rescue / ] $ gmirror label -b load -F swap /dev/gpt/swap0 /dev/gpt/swap1 [ root@rescue / ] $ gmirror label -b load -F boot /dev/gpt/boot0 /dev/gpt/boot1 [ root@rescue / ] $ geli onetime -d -e AES-XTS -l 256 -s 4096 /dev/mirror/swap [ root@rescue / ] $ echo __Your Password Here__ > /tmp/pw [ root@rescue ~ ] $ geli init -s 512 -J /tmp/pw /dev/gpt/zroot0 Metadata backup for provider /dev/gpt/zroot0 can be found in /var/backups/gpt_zroot0.eli and can be restored with the following command: # geli restore /var/backups/gpt_zroot0.eli /dev/gpt/zroot0 [ root@rescue ~ ] $ geli init -s 512 -J /tmp/pw /dev/gpt/zroot1 Metadata backup for provider /dev/gpt/zroot1 can be found in /var/backups/gpt_zroot1.eli and can be restored with the following command: # geli restore /var/backups/gpt_zroot1.eli /dev/gpt/zroot1 Install the stage-1 boot system (non-encrypted) \u00b6 This is the (mirrored) non-encrypted system that is used to boot into and ssh to in order to allow attaching the encrypted zroot pool of ZFS before rebooting into the ZFS partition. Prepare the filesystem \u00b6 [ root@rescue ~ ] $ newfs -U /dev/mirror/boot /dev/mirror/boot: 2048 .0MB ( 4194296 sectors ) block size 32768 , fragment size 4096 using 4 cylinder groups of 512 .00MB, 16384 blks, 65536 inodes. with soft updates super-block backups ( for fsck_ffs -b #) at: 192 , 1048768 , 2097344 , 3145920 [ root@rescue ~ ] $ tunefs -p /dev/mirror/boot tunefs: POSIX.1e ACLs: ( -a ) disabled tunefs: NFSv4 ACLs: ( -N ) disabled tunefs: MAC multilabel: ( -l ) disabled tunefs: soft updates: ( -n ) enabled tunefs: soft update journaling: ( -j ) disabled tunefs: gjournal: ( -J ) disabled tunefs: trim: ( -t ) disabled tunefs: maximum blocks per file in a cylinder group: ( -e ) 4096 tunefs: average file size: ( -f ) 16384 tunefs: average number of files in a directory: ( -s ) 64 tunefs: minimum percentage of free space: ( -m ) 8 % tunefs: space to hold for metadata blocks: ( -k ) 5240 tunefs: optimization preference: ( -o ) time tunefs: volume label: ( -L ) Check that soft update journaling is disabled! This will allow you to take live dumps. Install the FreeBSD system \u00b6 [ root@rescue / ] $ mount /dev/mirror/boot /mnt [ root@rescue / ] $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/base.txz | tar --unlink -xpJf - -C /mnt [ root@rescue / ] $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/lib32.txz | tar --unlink -xpJf - -C /mnt [ root@rescue / ] $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/kernel.txz | tar --unlink -xpJf - -C /mnt Boot configuration \u00b6 In order for the system to work correctly, specific kernel models need to be loaded at boot time and parameters set as follows: cat <<EOF >>/mnt/boot/loader.conf vfs.root.mountfrom=\"ufs:/dev/mirror/boot\" kern.geom.label.disk_ident.enable=\"0\" kern.geom.label.gptid.enable=\"0\" geom_mirror_load=\"YES\" geom_eli_load=\"YES\" zfs_load=\"YES\" EOF [ root@rescue ~ ] $ cat <<EOF >>/mnt/boot/loader.conf > vfs.root.mountfrom=\"ufs:/dev/mirror/boot\" > kern.geom.label.disk_ident.enable=\"0\" > kern.geom.label.gptid.enable=\"0\" > geom_mirror_load=\"YES\" > geom_eli_load=\"YES\" > zfs_load=\"YES\" > EOF Basic OS Configuration \u00b6 Ensure the system knows what to mount upon boot: [ root@rescue / ] $ echo /dev/mirror/boot / ufs rw 1 1 > /mnt/etc/fstab [ root@rescue / ] $ echo /dev/mirror/swap.eli none swap sw 0 0 >> /mnt/etc/fstab Create a basic configuration for this pre-boot OS (the file does not exist at this stage): cat <<EOF >>/mnt/etc/rc.conf # Pre-boot FreeBSD rc.conf # basic system to allow booting into encrypted zfs hostname=\"base-raw\" ifconfig_re0=\"DHCP\" # MAKE SURE YOU USE THE RIGHT INTERFACE NAME HERE sshd_enable=\"YES\" sendmail_enable=\"NONE\" cron_enable=\"NO\" EOF Change the root password \u00b6 [ root@rescue / ] $ chroot /mnt passwd root Changing local password for root New Password: Retype New Password: Setup timezone \u00b6 [ root@rescue / ] $ chroot /mnt tzsetup SSHd configuration \u00b6 Configure the way to connect to your new FreeBSD server via SSH. Follow the results of your security risks analysis. The following setup is based on root having access but only via private key. Start by allowing remote root logins: [ root@rescue / ] $ echo \"PermitRootLogin yes\" >> /mnt/etc/ssh/sshd_config [ root@rescue / ] $ echo \"PasswordAuthentication no\" >> /mnt/etc/ssh/sshd_config [ root@rescue / ] $ echo \"ChallengeResponseAuthentication no\" >> /mnt/etc/ssh/sshd_config and then generate the server\\'s keys: [ root@rescue / ] $ chroot /mnt /etc/rc.d/sshd onekeygen Copy your key in the authorized_keys file (to allow to connect by key) [ root@rescue / ] $ mkdir -p /mnt/root/.ssh [ root@rescue / ] $ chmod 700 /mnt/root/.ssh [ root@rescue / ] $ vi /mnt/root/.ssh/authorized_keys Reboot and continue configuration \u00b6 The time has come to reboot the server and see if it boots correctly from the new partition. Installation will continue from the newly booted server. Remember to login using your SSH key if you followed the above configuration. [ root@rescue / ] $ reboot Update FreeBSD \u00b6 Ensure you are running the latest version of FreeBSD $ freebsd-update fetch $ freebsd-update install and reboot in order to load the new kernel! Install the stage-2 FreeBSD system (encrypted) \u00b6 Boot into the freshly installed and updated FreeBSD base-raw system in order to continue with the installation of the main OS partition. Remember, encryption will take place using geli on the blk level and not under ZFS. Attach encrypted partitions \u00b6 We need to attach the partitions which are encrypted before creating the zpool . root@base-raw:~ $ geli attach /dev/gpt/zroot0 Enter passphrase: root@base-raw:~ $ geli attach /dev/gpt/zroot1 Enter passphrase: Create the zfs pool \u00b6 Alignment to sector size It is recommended to set the ashift parameter based on your physical sector size to ensure correct alignment. For a sector size of 512 bytes (2 9 ) you should set it to 9 (default). For a sector size of 4096 (4k, 2 12 ) you should set it to 12. As usually hardware does not evolve in cloud servers, there is no point to set it to 12 just to be future proof as you would have done on you own hardware. You may also want to adjust any other relevant ZFS parameters. root@base-raw:~ $ sysctl vfs.zfs.min_auto_ashift = 9 ; The zfs pool will hold the main filesystems where FreeBSD will be installed. The setup opts for a simple list of mount points. You may want to choose differently (like the default FreeBSD install) depending on the usage of the server. root@base2-raw:~ $ zpool create -f -m none -o altroot = /mnt -o cachefile = /tmp/zpool.cache zpool mirror /dev/gpt/zroot0.eli /dev/gpt/zroot1.eli Now create the filesystems we need: root@base2-raw:~ $ zfs create -o mountpoint = / zpool/root Install the FreeBSD system \u00b6 root@base2-raw:~ $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/base.txz | tar --unlink -xpJf - -C /mnt 147 MB 10 MBps 14s root@base2-raw:~ $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/lib32.txz | tar --unlink -xpJf - -C /mnt - 58 MB 10 MBps 06s root@base2-raw:~ $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/kernel.txz | tar --unlink -xpJf - -C /mnt - 39 MB 9269 kBps 05s Configure the stage-2 system \u00b6 Basic settings \u00b6 root@base2-raw:~ $ cp /boot/loader.conf /mnt/boot/loader.conf root@base2-raw:~ $ cp /etc/rc.conf /mnt/etc/rc.conf root@base2-raw:~ $ cp /etc/resolv.conf /mnt/etc/resolv.conf root@base2-raw:~ $ cp /etc/ssh/ssh_host_* /mnt/etc/ssh/ root@base2-raw:~ $ cp /etc/ssh/sshd_config /mnt/etc/ssh/ root@base2-raw:~ $ mkdir -p /mnt/root/.ssh root@base2-raw:~ $ chmod 700 /mnt/root/.ssh root@base2-raw:~ $ cp /root/.ssh/authorized_keys /mnt/root/.ssh/ root@base2-raw:~ $ echo 'daily_status_gmirror_enable=\"YES\"' >> /mnt/etc/periodic.conf root@base2-raw:~ $ mkdir -p /mnt/xboot root@base2-raw:~ $ chroot /mnt passwd root Changing local password for root New Password: Retype New Password: root@base2-raw:~ $ chroot /mnt tzsetup Security Warning Do not use the same password as for your stage-1 FreeBSD server. Remember that stage-1 boot relies on an unecrypted ufs filesystem. It is therefore possible that someone with access to the physical server may obtain the password file and reverse engineer your password. You may now change the hostname in /mnt/etc/rc.conf to base instead of base-raw (or to whatever you like). This may help you understand the system you have ssh\\'ed into. # # FreeBSD Encrypted Stage-2 Server Configuration # hostname = \"base\" ifconfig_re0 = \"DHCP\" zfs_enable = \"YES\" # # Daemons # sshd_enable = \"YES\" sendmail_enable = \"NONE\" ntpdate_enable = \"YES\" Edit the fstab file to mount the ufs boot partition to xboot cat <<EOF >>/mnt/etc/fstab /dev/mirror/boot /xboot ufs rw 1 1 /dev/mirror/swap.eli none swap sw 0 0 EOF Prepare a script automatically decrypt and boot to stage 2 \u00b6 Create a script under /root/boot_stage2 : #!/bin/sh set -x geli attach gpt/zroot0 geli attach gpt/zroot1 kenv vfs.root.mountfrom = \"zfs:zpool/root\" echo \"Ready to boot? press enter or Ctr-C to stop\" read a # If you want to change your network configuration in the stage-2 system, you will need # to clean up your network settings here (flush routes, etc.) reboot -r Use as sh /root/boot_stage2 . Boot the system to Stage-2 \u00b6 root@base-raw:/ $ zpool export zpool root@base-raw:/ $ kenv vfs.root.mountfrom = \"zfs:zpool/root\" root@base-raw:/ $ reboot -r Your connection will now drop. You should now ssh back to your new system! Tip In case you fail to connect to the newly booted system and you have no access to the console to debug the issue, you will need to request a reboot of your server. A frequent cause is badly configured networking (you are actually flying blind at this stage). Upon reboot, you will be booting to the Stage-1 system that will allow you to attach your two encrypted devices, import the zpool and mount the filesystem to edit the stage-2 configuration files. Upgrade FreeBSD \u00b6 Update the new installation to the latest patch level. Don\\'t forget, we are running under the updated kernel already! root@base:/ $ freebsd-update fetch root@base:/ $ freebsd-update install root@base:/ $ shutdown -r now When the system comes up, log in to your Stage-1 system and run the script to boot into the Stage-2 system by supplying your password for each of the two encrypted partitions. Post configuration of your Stage-2 FreeBSD server \u00b6 You can now do the final configuration steps for your secure FreeBSD server. Install the pkg system and basic packages \u00b6 root@base:~ $ pkg update The package management tool is not yet installed on your system. Do you want to fetch and install it now? [ y/N ] : y Bootstrapping pkg from pkg+http://pkg.FreeBSD.org/FreeBSD:12:amd64/quarterly, please wait... Verifying signature with trusted certificate pkg.freebsd.org.2013102301... done Installing pkg-1.14.6... Extracting pkg-1.14.6: 100 % Updating FreeBSD repository catalogue... Fetching meta.conf: 100 % 163 B 0 .2kB/s 00 :01 Fetching packagesite.txz: 100 % 6 MiB 6 .6MB/s 00 :01 Processing entries: 100 % FreeBSD repository update completed. 32006 packages processed. All repositories are up to date. root@base:~ $ pkg install -y bash ca_root_nss neoftech py37-speedtest-cli-2.1.2 Maintenance of your secure server \u00b6 While it may run un-interrupted for years, a FreeBSD server is a pet: it requires regular attention to ensure that the system is upgraded to the right patch level or the right version to ensure the best possible security. Keeping your system up to date means (carefully) updating your installed packages to their latest versions; updating FreeBSD to its latest patch level; updating FreeBSD to the next major and/or minor version. Applying patches to the secure FreeBSD means applying them both to the Stage-1 and Stage-2 system. Start by patching the Stage-2 system ( freebsd-update fetch; freebsed-update install ) , reboot to stage-1 and repeat the process. Reboot again to stage-1 and follow the steps to boot to stage-2. Your system is now updated.","title":"A Secure FreeBSD Server in the cloud"},{"location":"freebsd/secure-server/#installing-a-secure-freebsd-12-server-on-a-dedicated-cloud-machine","text":"","title":"Installing a secure FreeBSD 12 server on a dedicated cloud machine"},{"location":"freebsd/secure-server/#problem-statement","text":"This recipe describes how to install a secure FreeBSD Server on a bare-metal server to which you have but network access (no access to the console during installation and/or during boot). It is further assumed that the physical security of the machine cannot be fully guaranteed, hence encryption methods should be used to protect the server's data. While the FreeBSD installer offers the possibility to automagically install an encrypted system, it is based on the assumption that you will have console access during boot to introduce the passkey - something not always possible. The proposed setup ensures a kernel-level software RAID-1 configuration (for data integrity/availability), operating on an encrypted filesystem using ZFS (for data confidentiality) and with an encrypted swap partition.","title":"Problem Statement"},{"location":"freebsd/secure-server/#concepts","text":"The solution proposed by this recipe is based on the pattern of a two-stage booting process : a first boot in a basic ( ufs ) unencrypted partition which allows network ssh access (via key), followed by attaching the geli -encrypted filesystem (by introducing a password at command line) and the re-rooting of the running kernel to the encrypted filesystem, effectively re-booting the kernel from the new filesystem which is at this stage available un-encrypted to the kernel. Tip Re-rooting refers to the use of the reboot -r command (see man page ): After changing vfs.root.mountfrom with kenv(1) , reboot -r can be used to change the root filesystem while preserving kernel state . The pattern can be further enhanced by hardening the first boot stage to only execute the mount sequence through ssh . Such hardening will increase security but will make rescue operations (that may have to be operated under stage 1 boot) harder. It is therefore not considered in this document.","title":"Concepts"},{"location":"freebsd/secure-server/#ingredients","text":"To be able to execute this recipe, you will need a dedicated machine to which you have network access. The machine should have two equal-sized disks and enough memory to serve the corresponding disk capacity under zfs . The installation can be done either remotely (if the machine can network-boot on a FreeBSD copy) or through the console (if you have access to the console). How to boot to FreeBSD from the console is not covered in this document. Note The recipe has been tested on a dedicated server provided by https://www.hetzner.com/ as well on VirtualBox . The machine enjoyed 2X2TB hard disks, 32GB of ECC memory and an Intel Xeon processor. Hetzner offers a \"rescue\" system, network-booting to FreeBSD and assigning a temporary password. The recipe therefore starts from a booted version of FreeBSD on your server that can be accessed from your network. Warning This installation guide is not for the faint hearted (but you already knew that if you are here). You need to really understand what you are doing to avoid catastrophic failure. You should be comfortable with FreeBSD sysadmin tasks and a patient and zen attitude. Expect the unexpected when installing an OS in a new environment (e.g. if you do install in Hetzner pay specific attention to configuring the network which requires a point-to-point configuration).","title":"Ingredients"},{"location":"freebsd/secure-server/#inspect-your-system","text":"Log-in to your network-booted FreeBSD image as root. Obtain initial information about your server's hardware . Processor : [ root@rescue ~ ] $ sysctl -a hw.model hw.model: Intel ( R ) Xeon ( R ) CPU E3-1246 v3 @ 3 .50GHz Memory : [ root@rescue ~ ] $ sysctl -a | grep hw.*mem hw.physmem: 33950691328 hw.usermem: 33666101248 hw.realmem: 34359738368 hw.pci.host_mem_start: 2147483648 hw.cbb.start_memory: 2281701376 Network : [ root@rescue ~ ] $ ifconfig -a re0: flags = 8843 <UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500 options = 8209b<RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,WOL_MAGIC,LINKSTATE> ether 44 :44:44:44:44:44 inet 9 .9.9.9 netmask 0xffffffc0 broadcast 9 .9.9.127 media: Ethernet autoselect ( 1000baseT <full-duplex,master> ) status: active nd6 options = 29 <PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL> Disks [ root@rescue ~ ] $ sysctl kern.disks kern.disks: ada1 ada0 [ root@rescue ~ ] $ camcontrol devlist <WDC WD2000FYYZ-01UL1B2 01 .01K03> at scbus0 target 0 lun 0 ( pass0,ada0 ) <WDC WD2000FYYZ-01UL1B2 01 .01K03> at scbus1 target 0 lun 0 ( pass1,ada1 ) <AHCI SGPIO Enclosure 1 .00 0001 > at scbus2 target 0 lun 0 ( ses0,pass2 ) [ root@rescue ~ ] $ diskinfo -v ada0 | head -n3 ada0 512 # sectorsize 2000398934016 # mediasize in bytes (1.8T) [ root@rescue ~ ] $ camcontrol identify ada0 | grep sector sectors/track 63 sector size logical 512 , physical 512 , offset 0 LBA supported 268435455 sectors LBA48 supported 3907029168 sectors Physical sector sizes Take note of your physical sector size: It is important to take note of the size of your physical sector (here 512 bytes) to ensure correct alignment when creating the ZFS partitions. Example of 4K physical disk sectors: [ root@rescue ~ ] $ camcontrol identify ada0 | grep sector sectors/track 63 sector size logical 512 , physical 4096 , offset 0 LBA supported 268435455 sectors LBA48 supported 7814037168 sectors","title":"Inspect your System"},{"location":"freebsd/secure-server/#steps","text":"","title":"Steps"},{"location":"freebsd/secure-server/#partition-the-disks","text":"Following inspection of our system, we have recorded that the two disks are ada0 and ada1 with 512byte physical sectors. We partition each disks in 4 partitions each, using GPT: a (very small) boot partition (for the ufs-bootcode) a 2GB ufs FreeBSD-root partition to be mirrored (for the pre-boot FreeBSD version) an 8GB swap partition (to be encrypted and mirrored) what remains goes in a FreeBSD-zfs partition (to be encrypted using geli and gmirror or zfs mirror ) for n in 0 1 ; do \\ align = 512 # change to 4k if necessary gpart destroy -F ada ${ n } ; \\ gpart create -s gpt ada ${ n } ; \\ gpart add -b 64 -s 64k -t freebsd-boot ada ${ n } ; \\ gpart add -l boot ${ n } -s 2G -t freebsd-ufs -a ${ align } ada ${ n } ; \\ gpart add -l swap ${ n } -s 8G -t freebsd-swap -a ${ align } ada ${ n } ; \\ gpart add -l zroot ${ n } -t freebsd-zfs -a ${ align } ada ${ n } ; \\ gpart bootcode -b /boot/pmbr -p /boot/gptboot -i 1 ada ${ n } ; \\ done [ root@rescue ~ ] $ for n in 0 1 ; do \\ > align = 512 # change to 4k if necessary > gpart destroy -F ada ${ n } ; \\ > gpart create -s gpt ada ${ n } ; \\ > gpart add -b 64 -s 64k -t freebsd-boot ada ${ n } ; \\ > gpart add -l boot ${ n } -s 2G -t freebsd-ufs -a ${ align } ada ${ n } ; \\ > gpart add -l swap ${ n } -s 8G -t freebsd-swap -a ${ align } ada ${ n } ; \\ > gpart add -l zroot ${ n } -t freebsd-zfs -a ${ align } ada ${ n } ; \\ > gpart bootcode -b /boot/pmbr -p /boot/gptboot -i 1 ada ${ n } ; \\ > done gpart: arg0 'ada0' : Invalid argument ada0 created ada0p1 added ada0p2 added ada0p3 added ada0p4 added partcode written to ada0p1 bootcode written to ada0 gpart: arg0 'ada1' : Invalid argument ada1 created ada1p1 added ada1p2 added ada1p3 added ada1p4 added partcode written to ada1p1 bootcode written to ada1 Note that the errors noticed above can be safely ignored. They simply indicate that no partition table existed before to be deleted.","title":"Partition the disks"},{"location":"freebsd/secure-server/#prepare-the-mirrors-for-swap-and-boot","text":"Mirroring for the ufs and swap partitions will happen using the geom_mirror kernel module. Encryption will be done using the geli system. We encrypt the swap partition dynamically while we encrypt the zfs partition with a strong password. The ZFS filesystem will perform its own mirroring. Do not forget to adapt the sector size for geli if necessary (e.g. 4096 instead of 512)! [ root@rescue / ] $ kldload geom_mirror [ root@rescue / ] $ gmirror label -b load -F swap /dev/gpt/swap0 /dev/gpt/swap1 [ root@rescue / ] $ gmirror label -b load -F boot /dev/gpt/boot0 /dev/gpt/boot1 [ root@rescue / ] $ geli onetime -d -e AES-XTS -l 256 -s 4096 /dev/mirror/swap [ root@rescue / ] $ echo __Your Password Here__ > /tmp/pw [ root@rescue ~ ] $ geli init -s 512 -J /tmp/pw /dev/gpt/zroot0 Metadata backup for provider /dev/gpt/zroot0 can be found in /var/backups/gpt_zroot0.eli and can be restored with the following command: # geli restore /var/backups/gpt_zroot0.eli /dev/gpt/zroot0 [ root@rescue ~ ] $ geli init -s 512 -J /tmp/pw /dev/gpt/zroot1 Metadata backup for provider /dev/gpt/zroot1 can be found in /var/backups/gpt_zroot1.eli and can be restored with the following command: # geli restore /var/backups/gpt_zroot1.eli /dev/gpt/zroot1","title":"Prepare the mirrors for swap and boot"},{"location":"freebsd/secure-server/#install-the-stage-1-boot-system-non-encrypted","text":"This is the (mirrored) non-encrypted system that is used to boot into and ssh to in order to allow attaching the encrypted zroot pool of ZFS before rebooting into the ZFS partition.","title":"Install the stage-1 boot system (non-encrypted)"},{"location":"freebsd/secure-server/#prepare-the-filesystem","text":"[ root@rescue ~ ] $ newfs -U /dev/mirror/boot /dev/mirror/boot: 2048 .0MB ( 4194296 sectors ) block size 32768 , fragment size 4096 using 4 cylinder groups of 512 .00MB, 16384 blks, 65536 inodes. with soft updates super-block backups ( for fsck_ffs -b #) at: 192 , 1048768 , 2097344 , 3145920 [ root@rescue ~ ] $ tunefs -p /dev/mirror/boot tunefs: POSIX.1e ACLs: ( -a ) disabled tunefs: NFSv4 ACLs: ( -N ) disabled tunefs: MAC multilabel: ( -l ) disabled tunefs: soft updates: ( -n ) enabled tunefs: soft update journaling: ( -j ) disabled tunefs: gjournal: ( -J ) disabled tunefs: trim: ( -t ) disabled tunefs: maximum blocks per file in a cylinder group: ( -e ) 4096 tunefs: average file size: ( -f ) 16384 tunefs: average number of files in a directory: ( -s ) 64 tunefs: minimum percentage of free space: ( -m ) 8 % tunefs: space to hold for metadata blocks: ( -k ) 5240 tunefs: optimization preference: ( -o ) time tunefs: volume label: ( -L ) Check that soft update journaling is disabled! This will allow you to take live dumps.","title":"Prepare the filesystem"},{"location":"freebsd/secure-server/#install-the-freebsd-system","text":"[ root@rescue / ] $ mount /dev/mirror/boot /mnt [ root@rescue / ] $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/base.txz | tar --unlink -xpJf - -C /mnt [ root@rescue / ] $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/lib32.txz | tar --unlink -xpJf - -C /mnt [ root@rescue / ] $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/kernel.txz | tar --unlink -xpJf - -C /mnt","title":"Install the FreeBSD system"},{"location":"freebsd/secure-server/#boot-configuration","text":"In order for the system to work correctly, specific kernel models need to be loaded at boot time and parameters set as follows: cat <<EOF >>/mnt/boot/loader.conf vfs.root.mountfrom=\"ufs:/dev/mirror/boot\" kern.geom.label.disk_ident.enable=\"0\" kern.geom.label.gptid.enable=\"0\" geom_mirror_load=\"YES\" geom_eli_load=\"YES\" zfs_load=\"YES\" EOF [ root@rescue ~ ] $ cat <<EOF >>/mnt/boot/loader.conf > vfs.root.mountfrom=\"ufs:/dev/mirror/boot\" > kern.geom.label.disk_ident.enable=\"0\" > kern.geom.label.gptid.enable=\"0\" > geom_mirror_load=\"YES\" > geom_eli_load=\"YES\" > zfs_load=\"YES\" > EOF","title":"Boot configuration"},{"location":"freebsd/secure-server/#basic-os-configuration","text":"Ensure the system knows what to mount upon boot: [ root@rescue / ] $ echo /dev/mirror/boot / ufs rw 1 1 > /mnt/etc/fstab [ root@rescue / ] $ echo /dev/mirror/swap.eli none swap sw 0 0 >> /mnt/etc/fstab Create a basic configuration for this pre-boot OS (the file does not exist at this stage): cat <<EOF >>/mnt/etc/rc.conf # Pre-boot FreeBSD rc.conf # basic system to allow booting into encrypted zfs hostname=\"base-raw\" ifconfig_re0=\"DHCP\" # MAKE SURE YOU USE THE RIGHT INTERFACE NAME HERE sshd_enable=\"YES\" sendmail_enable=\"NONE\" cron_enable=\"NO\" EOF","title":"Basic OS Configuration"},{"location":"freebsd/secure-server/#change-the-root-password","text":"[ root@rescue / ] $ chroot /mnt passwd root Changing local password for root New Password: Retype New Password:","title":"Change the root password"},{"location":"freebsd/secure-server/#setup-timezone","text":"[ root@rescue / ] $ chroot /mnt tzsetup","title":"Setup timezone"},{"location":"freebsd/secure-server/#sshd-configuration","text":"Configure the way to connect to your new FreeBSD server via SSH. Follow the results of your security risks analysis. The following setup is based on root having access but only via private key. Start by allowing remote root logins: [ root@rescue / ] $ echo \"PermitRootLogin yes\" >> /mnt/etc/ssh/sshd_config [ root@rescue / ] $ echo \"PasswordAuthentication no\" >> /mnt/etc/ssh/sshd_config [ root@rescue / ] $ echo \"ChallengeResponseAuthentication no\" >> /mnt/etc/ssh/sshd_config and then generate the server\\'s keys: [ root@rescue / ] $ chroot /mnt /etc/rc.d/sshd onekeygen Copy your key in the authorized_keys file (to allow to connect by key) [ root@rescue / ] $ mkdir -p /mnt/root/.ssh [ root@rescue / ] $ chmod 700 /mnt/root/.ssh [ root@rescue / ] $ vi /mnt/root/.ssh/authorized_keys","title":"SSHd configuration"},{"location":"freebsd/secure-server/#reboot-and-continue-configuration","text":"The time has come to reboot the server and see if it boots correctly from the new partition. Installation will continue from the newly booted server. Remember to login using your SSH key if you followed the above configuration. [ root@rescue / ] $ reboot","title":"Reboot and continue configuration"},{"location":"freebsd/secure-server/#update-freebsd","text":"Ensure you are running the latest version of FreeBSD $ freebsd-update fetch $ freebsd-update install and reboot in order to load the new kernel!","title":"Update FreeBSD"},{"location":"freebsd/secure-server/#install-the-stage-2-freebsd-system-encrypted","text":"Boot into the freshly installed and updated FreeBSD base-raw system in order to continue with the installation of the main OS partition. Remember, encryption will take place using geli on the blk level and not under ZFS.","title":"Install the stage-2 FreeBSD system (encrypted)"},{"location":"freebsd/secure-server/#attach-encrypted-partitions","text":"We need to attach the partitions which are encrypted before creating the zpool . root@base-raw:~ $ geli attach /dev/gpt/zroot0 Enter passphrase: root@base-raw:~ $ geli attach /dev/gpt/zroot1 Enter passphrase:","title":"Attach encrypted partitions"},{"location":"freebsd/secure-server/#create-the-zfs-pool","text":"Alignment to sector size It is recommended to set the ashift parameter based on your physical sector size to ensure correct alignment. For a sector size of 512 bytes (2 9 ) you should set it to 9 (default). For a sector size of 4096 (4k, 2 12 ) you should set it to 12. As usually hardware does not evolve in cloud servers, there is no point to set it to 12 just to be future proof as you would have done on you own hardware. You may also want to adjust any other relevant ZFS parameters. root@base-raw:~ $ sysctl vfs.zfs.min_auto_ashift = 9 ; The zfs pool will hold the main filesystems where FreeBSD will be installed. The setup opts for a simple list of mount points. You may want to choose differently (like the default FreeBSD install) depending on the usage of the server. root@base2-raw:~ $ zpool create -f -m none -o altroot = /mnt -o cachefile = /tmp/zpool.cache zpool mirror /dev/gpt/zroot0.eli /dev/gpt/zroot1.eli Now create the filesystems we need: root@base2-raw:~ $ zfs create -o mountpoint = / zpool/root","title":"Create the zfs pool"},{"location":"freebsd/secure-server/#install-the-freebsd-system_1","text":"root@base2-raw:~ $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/base.txz | tar --unlink -xpJf - -C /mnt 147 MB 10 MBps 14s root@base2-raw:~ $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/lib32.txz | tar --unlink -xpJf - -C /mnt - 58 MB 10 MBps 06s root@base2-raw:~ $ fetch -o - http://ftp.freebsd.org/pub/FreeBSD/releases/amd64/12.1-RELEASE/kernel.txz | tar --unlink -xpJf - -C /mnt - 39 MB 9269 kBps 05s","title":"Install the FreeBSD system"},{"location":"freebsd/secure-server/#configure-the-stage-2-system","text":"","title":"Configure the stage-2 system"},{"location":"freebsd/secure-server/#basic-settings","text":"root@base2-raw:~ $ cp /boot/loader.conf /mnt/boot/loader.conf root@base2-raw:~ $ cp /etc/rc.conf /mnt/etc/rc.conf root@base2-raw:~ $ cp /etc/resolv.conf /mnt/etc/resolv.conf root@base2-raw:~ $ cp /etc/ssh/ssh_host_* /mnt/etc/ssh/ root@base2-raw:~ $ cp /etc/ssh/sshd_config /mnt/etc/ssh/ root@base2-raw:~ $ mkdir -p /mnt/root/.ssh root@base2-raw:~ $ chmod 700 /mnt/root/.ssh root@base2-raw:~ $ cp /root/.ssh/authorized_keys /mnt/root/.ssh/ root@base2-raw:~ $ echo 'daily_status_gmirror_enable=\"YES\"' >> /mnt/etc/periodic.conf root@base2-raw:~ $ mkdir -p /mnt/xboot root@base2-raw:~ $ chroot /mnt passwd root Changing local password for root New Password: Retype New Password: root@base2-raw:~ $ chroot /mnt tzsetup Security Warning Do not use the same password as for your stage-1 FreeBSD server. Remember that stage-1 boot relies on an unecrypted ufs filesystem. It is therefore possible that someone with access to the physical server may obtain the password file and reverse engineer your password. You may now change the hostname in /mnt/etc/rc.conf to base instead of base-raw (or to whatever you like). This may help you understand the system you have ssh\\'ed into. # # FreeBSD Encrypted Stage-2 Server Configuration # hostname = \"base\" ifconfig_re0 = \"DHCP\" zfs_enable = \"YES\" # # Daemons # sshd_enable = \"YES\" sendmail_enable = \"NONE\" ntpdate_enable = \"YES\" Edit the fstab file to mount the ufs boot partition to xboot cat <<EOF >>/mnt/etc/fstab /dev/mirror/boot /xboot ufs rw 1 1 /dev/mirror/swap.eli none swap sw 0 0 EOF","title":"Basic settings"},{"location":"freebsd/secure-server/#prepare-a-script-automatically-decrypt-and-boot-to-stage-2","text":"Create a script under /root/boot_stage2 : #!/bin/sh set -x geli attach gpt/zroot0 geli attach gpt/zroot1 kenv vfs.root.mountfrom = \"zfs:zpool/root\" echo \"Ready to boot? press enter or Ctr-C to stop\" read a # If you want to change your network configuration in the stage-2 system, you will need # to clean up your network settings here (flush routes, etc.) reboot -r Use as sh /root/boot_stage2 .","title":"Prepare a script automatically decrypt and boot to stage 2"},{"location":"freebsd/secure-server/#boot-the-system-to-stage-2","text":"root@base-raw:/ $ zpool export zpool root@base-raw:/ $ kenv vfs.root.mountfrom = \"zfs:zpool/root\" root@base-raw:/ $ reboot -r Your connection will now drop. You should now ssh back to your new system! Tip In case you fail to connect to the newly booted system and you have no access to the console to debug the issue, you will need to request a reboot of your server. A frequent cause is badly configured networking (you are actually flying blind at this stage). Upon reboot, you will be booting to the Stage-1 system that will allow you to attach your two encrypted devices, import the zpool and mount the filesystem to edit the stage-2 configuration files.","title":"Boot the system to Stage-2"},{"location":"freebsd/secure-server/#upgrade-freebsd","text":"Update the new installation to the latest patch level. Don\\'t forget, we are running under the updated kernel already! root@base:/ $ freebsd-update fetch root@base:/ $ freebsd-update install root@base:/ $ shutdown -r now When the system comes up, log in to your Stage-1 system and run the script to boot into the Stage-2 system by supplying your password for each of the two encrypted partitions.","title":"Upgrade FreeBSD"},{"location":"freebsd/secure-server/#post-configuration-of-your-stage-2-freebsd-server","text":"You can now do the final configuration steps for your secure FreeBSD server.","title":"Post configuration of your Stage-2 FreeBSD server"},{"location":"freebsd/secure-server/#install-the-pkg-system-and-basic-packages","text":"root@base:~ $ pkg update The package management tool is not yet installed on your system. Do you want to fetch and install it now? [ y/N ] : y Bootstrapping pkg from pkg+http://pkg.FreeBSD.org/FreeBSD:12:amd64/quarterly, please wait... Verifying signature with trusted certificate pkg.freebsd.org.2013102301... done Installing pkg-1.14.6... Extracting pkg-1.14.6: 100 % Updating FreeBSD repository catalogue... Fetching meta.conf: 100 % 163 B 0 .2kB/s 00 :01 Fetching packagesite.txz: 100 % 6 MiB 6 .6MB/s 00 :01 Processing entries: 100 % FreeBSD repository update completed. 32006 packages processed. All repositories are up to date. root@base:~ $ pkg install -y bash ca_root_nss neoftech py37-speedtest-cli-2.1.2","title":"Install the pkg system and basic packages"},{"location":"freebsd/secure-server/#maintenance-of-your-secure-server","text":"While it may run un-interrupted for years, a FreeBSD server is a pet: it requires regular attention to ensure that the system is upgraded to the right patch level or the right version to ensure the best possible security. Keeping your system up to date means (carefully) updating your installed packages to their latest versions; updating FreeBSD to its latest patch level; updating FreeBSD to the next major and/or minor version. Applying patches to the secure FreeBSD means applying them both to the Stage-1 and Stage-2 system. Start by patching the Stage-2 system ( freebsd-update fetch; freebsed-update install ) , reboot to stage-1 and repeat the process. Reboot again to stage-1 and follow the steps to boot to stage-2. Your system is now updated.","title":"Maintenance of your secure server"}]}